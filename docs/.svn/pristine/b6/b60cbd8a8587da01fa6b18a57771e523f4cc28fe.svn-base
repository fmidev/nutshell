#!/bin/python
# -*- coding: utf-8 -*-
"""
Product generator service.
Created on Sat May  2 09:54:21 2020

@author: mpeura
"""

__version__ = '0.1'
__author__ = 'Markus.Peura@fmi.fi'


import os
import re
#import argparse
#import shutil     # for mv 
import subprocess # for shell escape
from pathlib import Path
# For codes
#import http.server
from http import HTTPStatus

from . import nutils
from . import nutproduct


def parse_timestamp2(timestamp, result = {}):
    if (timestamp):
        t = re.sub("\W", "", timestamp)
        result['TIMESTAMP'] = t[0:12] # empty ok?
        result['YEAR']      = t[0:4]
        result['MONTH']     = t[4:6]
        result['DAY']       = t[6:8]
        result['HOUR']      = t[8:10]
        result['MINUTE']    = t[10:12]
    return result




ProductInfo = nutproduct.ProductInfo


class ProductServer:
    """Service designed for generating image and data products served as files 
    """

    PRODUCT_ROOT = '.'
    CACHE_ROOT = '.'
    TIME_DIR_SYNTAX = '{YEAR}/{MONTH}/{DAY}'
    SHELL_GENERATOR_SCRIPT = 'generate.sh'
    SHELL_INPUT_SCRIPT = 'input.sh'

    # HTTP Server Options (forward defs HTTP server, so perhaps later moved to NutServer )
    HTTP_PORT = 8088
    HTTP_NAME = ''
    HTTP_PATH_PREFIX = 'nutshell/' # todo
    HTML_ROOT = '.' # todo
    HTML_TEMPLATE = 'template.html' 

    stdout = subprocess.PIPE
    stderr = subprocess.PIPE

    verbosity = 5

    counter = 0
   
    @classmethod
    def get_arg_parser(cls, parser = None):
        """Populates parser with options of this class"""

        parser = nutproduct.ProductInfo.get_arg_parser(parser)
        # parser = argparse.ArgumentParser()

        #    parser.add_argument("-l", "--linkfile", dest="LINKFILE",
        #        default="link.h5",
        #        help="read input from file", metavar="<file>")
    
        parser.add_argument("-c", "--conf", dest="CONF",
                            default=None, # "nutshell.cnf", #ProductServer.CONF_FILE?
                            help="read config file", 
                            metavar="<file>")
    
        #parser.add_argument("-p", "--product", metavar="<id>|<file>",
        #                    dest="PRODUCT",
        #                    default="",
        #                    help="product to be handled")
    
        parser.add_argument("-r", "--request", metavar="<string>",
                            dest="REQUEST",
                            default="",
                            help="comma-separated string of [DELETE|MAKE|INPUTS]")
    
        parser.add_argument("-d", "--delete",
                            dest="DELETE",
                            action="store_true",
                            #default=False,
                            help="delete product file, same as -r DELETE")
    
        parser.add_argument("-m", "--make",
                            dest="MAKE",
                            action="store_true",
                            #default=False,
                            help="make product, same as -r MAKE")
    
        parser.add_argument("-i", "--inputList",
                            dest="INPUTS",
                            action="store_true",
                            help="list input for a product, same as -r INPUTS")
    
        parser.add_argument("-D", "--directives",
                            dest="DIRECTIVES",
                            default='',
                            help="additional instructions for product generation")
    
        #parser.add_argument("-v", "--verbose", metavar="<level>",
        #                    dest="VERBOSE",
        #                    type=int,
        #                    default=5, 
        #                    help="Print status messages to stdout")
        return parser    

    
        
    class ProductRequest:
        """Container for storing information on requested product and server side resources derived thereof.
        """

        """Server assigned for manufacturing this product"""
        product_server = None

        """Specification of a product instance."""
        product_info = None

        """System-side directory containing script () for generating the product"""
        generator_path = ''

        """Optional: System-side full path to the generated file, the product."""
        path = ''
        
        """Optional: System-side full path to the generated file, the product."""
        path_tmp = ''
     
        """Optional: Actual object (for example, python Image in the future) """
        product = None
        
        # Later, use (dir + file) object
        inputs = {}
        
        # Nutshell native log output
        log = None
        
        # Std output of the generation
        stdout = None
        
        # Error output of the generation
        stderr = None
        
        # Return code of the generation
        returncode = 0

        # Status, defined using HTTP status codes
        status = HTTPStatus.OK.value

        sid = 0
        
        def __init__(self, product_server, product_info):

            self.sid = (++ProductServer.counter)

            # Consider stripping 'product_'
            self.product_server = product_server
            self.product_info = product_info

            self.generator_path = Path(product_server.get_generator_dir(product_info), 
                                       product_server.SHELL_GENERATOR_SCRIPT)
            
            self.product = None
            self.inputs = {}
            self.log = nutils.Log()
           
            filename  = product_info.filename()
            cache_dir = product_server.get_cache_dir(product_info)
      
            # Target path. Will be cleared (to None) if product generation fails.
            self.path = Path(cache_dir, filename)
            self.path_tmp = Path(cache_dir, 'tmp', filename)  
            self.status = HTTPStatus.NO_CONTENT.value  #204 # No content
            self.returncode = -1
            # self.path_tmp = self.cache_dir+os.sep+self.out_file_tmp
   
    class _InputInfo:
        
        inputs = None
        
        # Std output of the generation
        stdout = None
        
        # Error output of the generation
        stderr = None

        #
        log = None
        
        #def __init__(self, product_info):
        #    self.gdir = self.get_generator_dir(product_info)
        #    self.inputs = {}
        #    self.log = Log()
    
    def InputInfo(self, product_info):
         info = self._InputInfo() 
         #info.gdir = self.get_generator_dir(product_info)
         #info.script = input_info.gdir + os.sep + self.SHELL_INPUT_SCRIPT
         info.script = Path(self.get_generator_dir(product_info),
                            self.SHELL_INPUT_SCRIPT)

         info.inputs = {}
         info.log = nutils.Log()
         return info
    
    def __init__(self, conffile = ''):
        if (conffile):
            self.read_conf(conffile)
        if __name__ == '__main__':
            self.stdout = os.sys.stdout # discarded
            self.stderr = os.sys.stderr


    def read_conf(self, conffile = 'nutshell.cnf', strict=True):
        if (os.path.exists(conffile)):
            result = nutils.read_conf(conffile)
            # print result
            nutils.set_entries(self, result)
        elif strict:
            raise FileNotFoundError("Conf file not found: ", conffile)
        else:
            print ("Conf file not found: ", conffile)  

    def get_status(self):  
        return nutils.get_entries(self)
    
    def get_product_dir(self, product_info):
        """Returns directory containing product generator script (generate.sh) and possible configurations etc"""
        return product_info.ID.replace('.', os.sep)
    
    def get_time_dir(self, timestamp):
        if (timestamp):
            timevars = nutproduct.parse_timestamp(timestamp)
            # print timevars
            return self.TIME_DIR_SYNTAX.format(**timevars)+os.sep
        else:
            return ''
    
    def get_generator_dir(self, product_info):
        return self.PRODUCT_ROOT+os.sep+product_info.ID.replace('.', os.sep)

    # needed?
    def get_cache_dir(self, product_info):
        timedir = self.get_time_dir(product_info.TIMESTAMP)
        return self.CACHE_ROOT + os.sep + timedir + self.get_product_dir(product_info)

    def get_relative_path(self, product_info):
        time_dir = self.get_time_dir(product_info.TIMESTAMP)
        prod_dir = self.get_product_dir(product_info)
        return 'cache' + os.sep + time_dir + prod_dir + os.sep + product_info.filename()

    def get_auxiliary_dir(self, product_info, format):
        """ Archive or storage (read-only)"""
        #timedir = self.get_time_dir(product_info.TIMESTAMP)
        #product_dir = product_info.ID.replace('.', os.sep)
        return "self.CACHE_ROOT + os.sep + timedir + self.get_product_dir(product_info)"


    # Generalize?
    def ensure_output_dir(self, outdir):
        """Creates, if non-existent
        """
        try:
            original_umask = os.umask(0)
            os.makedirs(str(outdir), 0o775, True)
            #os.makedirs('full/path/to/new/directory', desired_permission)
        finally:
            os.umask(original_umask)
        return outdir


    def get_input_list(self, product_info, directives = None):
        """ Used for reading dynamic input configuration generated by input.sh.
        directives determine how the product is generated. 
        """

        input_info = self.InputInfo(product_info)

        #print("S", input_info.script)

        #if (os.path.exists(input_info.script)):
        if (input_info.script.exists()):
            # TODO generalize (how)
            env = product_info.get_param_env()
            if (directives):
                env.update(directives) 
            #print env # !DEBUG
            #input_info.log(env)
            nutils.print_dict(directives)
            nutils.print_dict(env)
            
            p = subprocess.Popen(str(input_info.script),
                                 cwd=str(input_info.script.parent),
                                 stdout=subprocess.PIPE, # always
                                 stderr=self.stderr, # stdout for cmd-line and subprocess.PIPE (separate) for http usage
                                 shell=True,
                                 env=env)
        
            input_info.stdout,input_info.stderr = p.communicate()

            if (input_info.stdout):
                input_info.stdout = input_info.stdout.decode(encoding='UTF-8')
            if (input_info.stderr):
                input_info.stderr = input_info.stderr.decode(encoding='UTF-8')

            
            #print "Verbosity = {0}".format(type(self.verbosity))
            if (self.verbosity > 8):
                print('------------STDERR------------')
                print(input_info.stderr)
                print('------------STDOUT------------')
                print(input_info.stdout)
                print("Return code={0}".format(p.returncode))

            #print(type(input_info.stdout))
            lines = input_info.stdout.split('\n')
        
            if (p.returncode == 0):
                nutils.read_conf_text(lines, input_info.inputs)
                if (self.verbosity > 9):
                    #print("input_info.inputs **")
                    nutils.print_dict(input_info.inputs)
            else:
                print("Errors (code={0}):".format(p.returncode))
                print('------------')
                print( input_info.stderr)
                print('------------')
                print( input_info.stdout)
                #print('pushd',input_info.gdir )
                e=''
                for k,v in env.items():
                    e += ' {0}="{1}"'.format(k,v)
                #print (e, '.'+os.sep+self.SHELL_INPUT_SCRIPT)
                print (e)
                raise SyntaxWarning(lines.pop())  #last
            
        #return input_info.inputs
        return input_info
        

         
    def run_generator(self, product_request, params=None):
        """ Run shell script to generate a product. 
        Actually, only generator_dir is read as parameter. 
        Then, stdout and stderr are used for output.
        
        Attributes:
          product_request -- state at beginning of transition.
          params -- attempted new state.
        """

        if (params == None):
            params = {}
             
        if (self.verbosity > 10):
            print ('Params:', params)
            print ('Generator:', product_request.generator_path)

        nutils.debug_dict(params)     
            
        p = subprocess.Popen(str(product_request.generator_path), #'./'+self.SHELL_GENERATOR_SCRIPT,
                             cwd=str(product_request.generator_path.parent),
                             stdout=subprocess.PIPE,  #self.stdout,
                             stderr=subprocess.STDOUT, # Use same stream as stdout, be it os.stdout or subprocess.STDOUT
                             shell=True,
                             env=params)
                             
        print ('ASIAA', p)
        if (not p):
            product_request.status = HTTPStatus.NOT_FOUND # Not Found
            #print ("Could not execute path=" + path)
            product_request.returncode = -1
            return -1
            
        (product_request.stdout, product_request.stderr) = p.communicate()

        product_request.returncode = p.returncode
        if (p.returncode == 0):
            product_request.product = product_request.path
            product_request.status = HTTPStatus.OK.value #200 # OK
        else:
            product_request.status = HTTPStatus.NO_CONTENT.value
            
        return p.returncode



    def make_request(self, product_info, actions = ['MAKE'], directives = None):
        """" Return path or log
        'MAKE' - return the product, if in cache, else generate it and return
        'GENERATE' - generate and store the product, also regenerate even if already exists
        'INPUTS' - generate and store the product, also regenerate even if already exists
        """

        # 'TEST' - generate and store the product, also regenerate even if already exists

        if (self.verbosity > 10):
            print ('Actions:' + ','.join(actions))


        # Consider also separate creation and then make_request(product_request)
        product_request = self.ProductRequest(self, product_info)

        product_request.log('Actions:', actions)
        
        #if (os.path.exists(product_request.path)):
        if (product_request.path.exists()):  
            product_request.log('File exists: {0}'.format(product_request.path))
            if ('DELETE' in actions):
                product_request.log('Deleting...')
                product_request.path.unlink()
            elif ('MAKE' in actions): # PATH_ONLY
                #if (os.stat(product_request.path).st_size > 0):
                if (product_request.path.stat().st_size > 0):
                    product_request.product = product_request.path
                    product_request.status = HTTPStatus.OK.value
                else:
                    product_request.product = '' # BUSY
                    product_request.status = HTTPStatus.ACCEPTED.value  #202 # Accepted
                    product_request.log('BUSY')
                return product_request
        else:
            product_request.log('File not found: {0}'.format(product_request.path))

        # only check at this point
        #if (os.path.exists(product_request.generator_script)):
        if (product_request.generator_path.exists()):
            product_request.log('Generator script ok: {0}'.format(product_request.generator_path))
        else:
            product_request.log('Generator script not found: {0}'.format(product_request.generator_path))
            # Consider case of copied valid product (without local generator)            
            product_request.path = ''
            product_request.status = HTTPStatus.NOT_IMPLEMENTED.value # Not Implemented
            return product_request
        

        # TODO: if not stream?
        params = {}
        if ('MAKE' in actions):
            product_request.log('Ensuring cache dir for: {0}'.format(product_request.path))
            self.ensure_output_dir(product_request.path_tmp.parent)
            self.ensure_output_dir(product_request.path.parent)

            # TODO: what about true ENV?
            params = product_info.get_param_env() # {})
            params['OUTDIR']  = str(product_request.path_tmp.parent)
            params['OUTFILE'] = product_request.path.name
            #os.mknod(product_request.path) # = touch
            product_request.path.touch()
            
        # Runs input.sh
        product_request.inputs = self.get_input_list(product_info, directives).inputs

        if ('MAKE' in actions):
            # print 'Retrieve inputs'
            inputs = {}
            for i in product_request.inputs:
                product_request.log('INPUTFILE: ', i)
                input = product_request.inputs[i] # <filename>.h5
                input_prod_info = nutproduct.ProductInfo(input)
                print ('Make input: {0} ({1})'.format(i, input_prod_info.ID))
                r = self.make_request(input_prod_info, ['MAKE'] )
                if (r.path):
                    inputs[i] = str(r.path) # sensitive
                print ('INPUTPATH: ', r.path)
            product_request.log('INPUTPATH: ', inputs)

            product_request.inputs = inputs
            #product_request.log.extend2(product_request.inputs , 'INPUTPATH: ')

            params['INPUTKEYS'] = ','.join(product_request.inputs.keys())
            params.update(product_request.inputs)

        #print "ENVI2"
        #nutils.print_dict(params)
        #product_request.log("----")
     
        # MAIN
        if ('MAKE' in actions):
            product_request.log('Generating: ', product_request.path )
            self.run_generator(product_request, params)

            if (product_request.returncode != 0):
                print ("WRONK", product_request.stderr)
                return product_request
                
            if (product_request.path_tmp.stat().st_size > 0):
                product_request.path_tmp.replace(product_request.path)
                #shutil.move(product_request.path_tmp, product_request.path)
                
            if ('DEBUG' in directives):
                logfile = Path(str(product_request.path) + '.log')
                logfile.write_text(product_request.stdout.decode(encoding='UTF-8'))            
                
           
        return product_request
    




        
if __name__ == '__main__':

    #print()
    
    # parser = argparse.ArgumentParser()
    parser = ProductServer.get_arg_parser()
    #ProductInfo.get_arg_parser(parser)

    
    #(options, args) = parser.parse_args()
    options = parser.parse_args()

    if (not options):
        parser.print_help()
        exit(1)
    
    if (options.VERBOSE > 10):
        print(options)
    #print args

    product_info = nutproduct.ProductInfo()

    if (options.PRODUCT):
        product_info.parse_filename(options.PRODUCT)
        
    product_server = ProductServer()
    product_server.verbosity = options.VERBOSE

    if (options.CONF):
        if (options.VERBOSE > 5):
            print ("reading conf file: {0}".format(options.CONF))
        product_server.read_conf(options.CONF)

    if (options.VERBOSE > 4):
        nutils.print_dict(product_server.get_status())
         
    request = []
    
    if (options.INPUTS):
        request.append('INPUTS')

    if (options.REQUEST):
        request.append(options.REQUEST.split(','))
        
    if (options.DELETE):
        request.append('DELETE')

    if (options.MAKE) or not (request):
        request.append('MAKE')

    if (product_info.ID and product_info.FORMAT):
        
        if (options.VERBOSE > 4):
            print('Requests: {0}'.format(str(request)))

        directives = {}
        if (options.DIRECTIVES):
            directives = nutils.read_conf_text(options.DIRECTIVES.split(',')) # whattabout comma in arg?

        product_request = product_server.make_request(product_info, request, directives)
        if (options.VERBOSE > 5):
            print (product_request.log)

        if ('INPUTS' in request) or (options.VERBOSE > 6):
            nutils.print_dict(product_request.inputs)

        print (product_request.status)
    else:
        print('Could not parse product')
        
    exit(0)
