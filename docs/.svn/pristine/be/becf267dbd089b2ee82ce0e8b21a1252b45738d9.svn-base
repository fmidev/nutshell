#!/bin/python3
# -*- coding: utf-8 -*-
"""
**Product generator helper classes.**

Variable parsing
================

Parsing can be tested interactively:

>>> import nutshell.product
>>> p = nutshell.product.Info("201708121600_my.test.product_SIZE=300.pgm.gz")



Main variables
--------------

=============== =========================== ==================
Variable        Description                 Example  
=============== =========================== ==================
``PRODUCT``     Product id, eg.             "my.test.product"  
``TIMESTAMP``\  Time attribute of a product "201708121600"
\-- ``YEAR``    Year (4 digits)             "2017"
\-- ``MONTH``   Month (2 digits)            "08"
\-- ``DAY``     Day (2 digits)              "12"
\-- ``HOUR``    Hour (2 digits)             "16"
\-- ``MINUTE``  Minute (2 digits)           "00"
``PARAMETERS``  Product specific variables  {"SIZE": "300", "NAME": "X"}
\-- ``<KEY>``   Name of a variable           "300"             
\-- ``<KEY>``   Name of a variable           "X"             
\--  ...        ...                         ...             
``EXTENSION``   File format, 
                including compression       "txt.gz"
``FORMAT``      File format                 "txt"
``COMPRESSION`` File compression            "gz"
=============== =========================== ==================




Code documentation
==================

"""

__version__ = '0.2'
__author__ = 'Markus.Peura@fmi.fi'

#import os
import re
#import subprocess # for shell escape

import argparse

from pathlib import Path
from http import HTTPStatus
#import http.server
#HTTPresponses = http.server.SimpleHTTPRequestHandler.responses

import logging
logging.basicConfig(format='%(levelname)s\t %(name)s: %(message)s')
#logging.basicConfig(format='%(levelname)s:%(message)s', level=logging.DEBUG)
#logging.basicConfig(format='%(asctime)s %(message)s', datefmt='%m/%d/%Y %I:%M:%S %p')
#logging.basicConfig(format='%(asctime)s %(levelname)s %(name)s : %(message)s', datefmt='%Y%m%d%H:%M:%S')

#from . import nutils
#from . import nutproduct

from . import generator


def parse_timestamp2(timestamp, result = {}):
    if (timestamp):
        t = re.sub("\W", "", timestamp)
        result['TIMESTAMP'] = t[0:12] # empty ok?
        result['YEAR']      = t[0:4]
        result['MONTH']     = t[4:6]
        result['DAY']       = t[6:8]
        result['HOUR']      = t[8:10]
        result['MINUTE']    = t[10:12]
    return result




class Info:
    """Stores basic product information: product id, timestamp (if applicable)
    file format, and specific product parameters.
    
    Technically independent of environment and other classes.
    Does not store local information or configurations (system side paths etc.).

    Attributes:
        previous -- state at beginning of transition
        next -- attempted new state
        message -- explanation of why the specific transition is not allowed

    """

    TIMESTAMP = ''
    ID = ''
    PARAMETERS = None #{}
    #PARAMS = None #[]
    FORMAT = ''
    COMPRESSION = ''
    EXTENSION = ''

    # \w = [a-zA-Z0-9_]

    # Resolve compression, if any. Plain compression not accepted, base format has to appear.
    # compressionRe = re.compile("^(.*\\.[a-z][a-z0-9]*)\\.(zip|gz)$")
    compressionRe = re.compile("^(.*)\\.(zip|gz)$")

    # Resolve extension = <format>.<compression>
    # extensionRe = re.compile("^([a-z][a-z0-9]*)(\\.(zip|gz))?$")
    extensionRe = re.compile("^((.*)\\.)?([a-z][a-z0-9]*)$")    

    # Resolve TIMESTAMP, PRODUCT_ID, PARAMETERS
    filenameRe = re.compile("^(([0-9]+)_)?([^_]+)(_(.*))?\\.([a-z][a-z0-9]*)$")

    prodRe = re.compile("^([a-z][a-z0-9]*)(\.[a-z][a-z0-9]*)*$")

    def set_id(self, product_id):
        """Set the product ID string consisting of alphanumeric chars and periods.""" 
        if (self.prodRe.match(product_id)):
            self.ID = product_id
        else:
            raise NameError('Value not accepted as product id: {}'.format(product_id))

    def set_product(self, product_desc, **kwargs):
        """Configure a product. 
        
        Arguments:
        product_desc -- a product ID string or a filename
        kwargs  -- keyword arguments completing the product definition
        """
        if (self.prodRe.match(product_desc)):
            self.ID = product_desc
            self.set_parameters(kwargs)
        else:
            self.parse_filename(product_desc)
            # todo warn if duplicates in kwargs?
            self.set_parameters(kwargs)
    
    def set_timestamp(self, timestamp):
        """Set UTC time in numeric format '%Y%m%d%H%M' or its punctuated variants.
        
        Essentially, the timestamp will be stored as a string of 
        12 digits, "202003291845" for example.
        
        The numbers have to be in order year, month, day, hour, and minute.
        Non-digits will be simply removed.
        For example, 2020/03/29 18:45 is pruned to 202003291845.
        Consequently, possible _time zones_ will be also discarded. 
        
        Todo: support for time object, unix seconds and date string parsing.
        """
        
        self.TIMESTAMP = re.sub("\W", "", timestamp)

    def set_format(self, extension):
        """Sets file format (png, txt, pgm.gz, txt.zip, ...)."""
        
        m = Info.compressionRe.match(extension)
        if (m):
            # replace None's with empty string
            m = m.groups('')
            # redo with compression stripped
            self.set_format(m[0])
            self.COMPRESSION = m[1]
            self.EXTENSION = self.FORMAT+'.'+self.COMPRESSION
        else:
            m = Info.extensionRe.match(extension)
            print (m)
            if (m):
                # replace None's with empty string
                m = m.groups('')
                self.FORMAT = m[2]
                self.EXTENSION = self.FORMAT
                self.COMPRESSION = ''
            else:
                raise SyntaxError("could nut parse: " + extension)
        print (self.__dict__)

    # NOTE: remove PARAMS!
    # Consider typing (int, str)
    def set_parameter(self, key, value=''):
        """Set any parameter, including FORMAT, excluding TIMESTAMP and ID
        
            Arguments:
                key -- a string identfying of a parameter or the product
                value -- the value of the parameter, possibly not 
                    string but stringifiable
        """

        if (key == 'FORMAT'):
            # warn?
            self.FORMAT = value
            # todo: EXTENSION, COMPR, TIMESTAMP?
            return

        if (self.PARAMETERS == None):
            self.PARAMETERS = {}

        self.PARAMETERS[key] = value

    def set_parameters(self, params):
        """Given a dictionary of parameters, set values.
        
        """
        for k,v in params.items():
            self.set_parameter(k, v)


    def parse_filename(self, filename):
        """Derive product parameters from a filename."""

        m = self.compressionRe.match(filename)
        if (m):
            # print 'Compression: {0}'.format(m.group(3))
            self.COMPRESSION = m.group(2)
            filename = m.group(1)

        m = self.filenameRe.match(filename)
        if (m):

            #print (m.groups()) # !DEBUG

            # Time variables
            if (m.group(2)):
                self.set_timestamp(m.group(2))
                #self.TIMESTAMP =  re.sub("\W", "", m.group(2))
            else:
                self.set_timestamp('')

            # Product id
            self.ID = m.group(3)

            # Product specific parameters
            #if (len(m.groups()) > 5):
            if (m.group(5)):
                # pindex = 0
                for e in m.group(5).split('_'): #self.PARAMS:
                    entry = e.split('=')
                    self.set_parameter(*entry)
                    #if (len(entry) == 1):
                    #    self.set_parameter('P'+str(pindex), entry[0])

            # Format, excluding optional COMPRESSION (parsed above)
            self.FORMAT = m.group(6)
            if (self.COMPRESSION):
                self.EXTENSION = self.FORMAT + '.' + self.COMPRESSION
            else:
                self.EXTENSION = self.FORMAT
            
        else:
            print ("{0}: ERROR in parsing {1}").format(__name__, filename)

        return self


    def filename(self):
        body = []
        if (self.TIMESTAMP):
            body.append(self.TIMESTAMP)
        body.append(self.ID)

        #if (self.PARAMS):
        #    body.append("_".join(self.PARAMS))

        if (self.PARAMETERS):
            for key,value in sorted(self.PARAMETERS.items()):
                if (value == ''):
                    body.append(key)
                else:
                    body.append("{0}={1}".format(key, value))
        return("_".join(body) + '.' + self.FORMAT)

    def filename_latest(self):
        body = ['LATEST', self.ID]
        if (self.PARAMETERS):
            for key,value in sorted(self.PARAMETERS.items()):
                if (value == ''):
                    body.append(key)
                else:
                    body.append("{0}={1}".format(key, value))
        return("_".join(body) + '.' + self.FORMAT)


    def get_param_env(self, env=None):
        """ Append or create dict with TIMESTAMP and params"""
        """ Uses PRODUCT instead of ID which is too general (example: "radar.rack.comp")"""
        if (env == None):
            env = {}

        # Start with these (and override with 'system' variables below).
        env.update(self.PARAMETERS)

        if (self.TIMESTAMP):
            parse_timestamp2(self.TIMESTAMP, env)

        env['PRODUCT'] = self.ID

        for i in ['FORMAT', 'COMPRESSION', 'EXTENSION']:
            env[i] = getattr(self, i, "")

        return env

    # Todo: params
    def __init__(self, product = ''):
        self.PARAMETERS = {}
        if (product):
            self.set_product(product)

    def __call__(self):
        print('Print Something')


    @classmethod
    def get_arg_parser(cls, parser = None):
        """Populates parser with options of this class"""

        if (not parser):
            parser = argparse.ArgumentParser()


        parser.add_argument("-l", "--log_level", metavar='DEBUG|INFO|ERROR|CRITICAL',
                            dest="LOG_LEVEL",
                            type=str,
                            default="",
                            help="Print status messages to stdout")
 
        parser.add_argument("-v", "--verbose",
                            dest="VERBOSE",
                            action="store_true",
                            help="Same as --log_level 0 : print all status messages")

#        parser.add_argument("-f", "--product_filename", metavar="<filename>",
#                            dest="OUTFILE",
#                            default="",
#                            help="product to be handled")

        parser.add_argument("-p", "--product", metavar="[<filename><id>]",
                            dest="PRODUCT",
                            default="",
                            help="product to be handled")


        return parser

        
class Request(generator.Task):
    """Container for storing information on requested product and server side resources derived thereof.
    """

    product_server = None
    """Server assigned for manufacturing this product"""

    product_info = None
    """Specification of a product instance."""

    #generator_path = ''
#    script = ''
#    """System-side directory containing script () for generating the product"""

    path = ''
    """System-side full path to a dynamic directory and the generated product file."""
    
    """System-side full path to the generated file, the product."""
    path_static = ''        
    
    """Optional: System-side full path to the generated product file."""
    path_tmp = ''
 
    """Optional: Actual object (for example, python Image in the future) """
    product_obj = None
    
    # Later, use (dir + file) object
    inputs = {}
    
    actions = []
    directives = []
    
#    # 
#    log = None
#    
#    # Std output of the generation
#    stdout = None
#    
#    # Error output of the generation
#    stderr = None
#    
#    # Return code of the generation
#    returncode = 0

    # Status, defined using HTTP status codes
    status = HTTPStatus.OK

    sid = 0
    
    builtin_directives = ("LOG", "LATEST", "LINK")        

    def set_status(self, status):
        """Set success or failure status using http.HTTPStatus codes.
        This is always logged.
        """
        self.log.debug(status)
        self.status = status
    
    def __init__(self, product_server, product_info, actions=None, directives=None, log=None):

        if not log:
            log = logging.getLogger("ProductRequest")
        
        super().__init__(Path(product_server.get_generator_dir(product_info),
                           product_server.SHELL_GENERATOR_SCRIPT), log=log) # ! env dropped 
        
        # Consider stripping 'product_'
        self.product_server = product_server

        if (type(product_info) == str):
            self.product_info = Info(product_info)
        else:        
            self.product_info = product_info

        #if log:
        #    self.log = log
        #else:
        #    self.log = logging.getLogger("ProductRequest")
 
 
        # generator_path
        #self.script = Path(product_server.get_generator_dir(self.product_info), 
        #                           product_server.SHELL_GENERATOR_SCRIPT)
        
        if (actions):
            self.actions = actions
        else:
            self.actions = []
        self.log.debug('actions:' + str(actions))
  
        if (directives):              
            self.directives = directives
        else:
            self.directives = []
        self.log.debug('directives: ' + str(self.directives))

        self.product_obj = None
        self.inputs = {}
       
        filename        = self.product_info.filename()
        filename_latest = self.product_info.filename_latest()

        cache_root = Path(product_server.CACHE_ROOT)
        cache_root = str(cache_root.absolute())
        time_dir = product_server.get_time_dir(self.product_info)
        prod_dir = product_server.get_product_dir(self.product_info)
  
  
        # Target path. Will be cleared (to None) if product generation fails.
        self.path_relative = Path(time_dir, prod_dir, filename)
        self.path =          Path(cache_root, time_dir, prod_dir, filename)
        self.path_tmp =      Path(cache_root, time_dir, prod_dir, 'tmp', filename)  
        self.path_static =   Path(cache_root, prod_dir, filename)
        self.path_latest =   Path(cache_root, prod_dir, filename_latest)
        
        self.set_status( HTTPStatus.NO_CONTENT)  #204 # No content
        self.returncode = -1
        
        # self.path_tmp = self.cache_dir+os.sep+self.out_file_tmp


class InputQuery(generator.Task):
    
    inputs = None
    
#    # Std output of the generation
#    stdout = None
#    
#    # Error output of the generation
#    stderr = None
#
#    #
#    log = None
#    
#    script = None
#
#    env = None
#    
#    returncode = 0
    #def __init__(self, product_info):
    #    self.gdir = self.get_generator_dir(product_info)
    #    self.inputs = {}
    #    self.log = Log()

    def __init__(self, product_server, product_info, env = None, log = None):

        super().__init__(Path(product_server.get_generator_dir(product_info),
                           product_server.SHELL_INPUT_SCRIPT), env, log)        
        
        if (type(product_info) == str):
            product_info = Info(product_info)
        
        #self.script = Path(product_server.get_generator_dir(product_info),
        #                   product_server.SHELL_INPUT_SCRIPT)
        self.inputs = {}
        
        self.env = product_info.get_param_env()

#        if (log):
#            self.log = log
#        else:
#            self.log = logging.getLogger("InputInfo"+__name__)  #nutils.Log()
     
        self.returncode = 0
                

   


if __name__ == '__main__':

    # parser = argparse.ArgumentParser()
    parser = Info.get_arg_parser()

    # Consider leaving "rare" or specific params in-class
    parser.add_argument("-s", "--set", metavar="[<id>|<filename>]",
                        dest="SET",
                        default="",
                        help="product to be handled, recognises argument type")

    parser.add_argument("-F", "--format", metavar="[<file_format>]",
                        dest="FORMAT",
                        default="",
                        help="sets product format explicitly, called with -p")

    options = parser.parse_args()

    if (not options):
        parser.print_help()
        exit(1)

    logger = logging.getLogger(__name__)
    logger.setLevel(30)
    
    product_info = Info()

    if (options.VERBOSE):
        options.LOG_LEVEL = "DEBUG"
        
    if (options.LOG_LEVEL):
        if hasattr(logging, options.LOG_LEVEL):
            #nutils.VERBOSITY_LEVELS[options.VERBOSE]
            logger.setLevel(getattr(logging, options.LOG_LEVEL))
        else:
            logger.setLevel(int(options.LOG_LEVEL))
    
    logger.debug(options)   
    
 
    if (options.OUTFILE):
        product_info.parse_filename(options.OUTFILE)

    if (options.PRODUCT):
        product_info.set_id(options.PRODUCT)
    if (options.PRODUCT):
        product_info.parse_filename(options.PRODUCT)
    else:
        logger.warning("product not defined")
 

    if (options.SET):
        args = {'SIZE': [640,400], 'FORMAT': 'png', 'VERSION': 2.0}
        product_info.set_product(options.SET, **args)


    if (product_info.ID):
        if (options.FORMAT):
            product_info.set_format(options.FORMAT)
        print(product_info.filename())
        print(product_info.get_param_env()) # contains ID
        #print(product_info.__dict__) # contains ID
        exit(0)
    else:
        print('Error: Product not given')
        parser.print_help()
        exit(1)

    
    