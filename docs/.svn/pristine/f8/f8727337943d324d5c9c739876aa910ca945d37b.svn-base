#!/bin/python
"""Product generator service. """

__version__ = '0.1'
__author__ = 'Markus.Peura@fmi.fi'

#os.environ["http_proxy"]="" #

import os
import re
import argparse
import subprocess # for shell escape

from . import nutils



def parse_timestamp(timestamp, result = {}):
    if (timestamp):
        t = re.sub("\W", "", timestamp)
        result['TIMESTAMP'] = t[0:12] # empty ok?
        result['YEAR']      = t[0:4]
        result['MONTH']     = t[4:6]
        result['DAY']       = t[6:8]
        result['HOUR']      = t[8:10]
        result['MINUTE']    = t[10:12]
    return result


class Log:

    log = []

    def append(self, line, prefix = 'LOG: '):
        self.log.append(prefix + line)

    def extend(self, lines, prefix = ''):
        # lines = lines.split('\n')
        for i in lines:
            self.append(i, prefix)

    def extend2(self, array, prefix = ''):
        for i in array:
            self.append(i+' = '+ array[i], prefix)

    def str(self):
        #s = ''
        #for i in self.log:
        #    s += 'LOG: {0}\n'.format(i)
        #return s
        return '\n'.join(self.log)

#def getAssignments(product_info):
#    return ''.join("%s='%s' " % (key,value) for key,value in product_info.iteritems())

class ProductInfo:
    """Basic product information.
    Independent of environment. Does not store local information or configurations (system side paths etc.). 
    """

    TIMESTAMP = ''
    ID = ''
    PARAMETERS = None #{}
    #PARAMS = None #[]
    FORMAT = ''
    COMPRESSION = ''
    EXTENSION = ''

    # Resolve compression, if any
    compressionRe = re.compile("^(.*)\\.(zip|gz)$");

    # Resolve TIMESTAMP, PRODUCT_ID, PARAMETERS
    productRe = re.compile("^(([0-9]+)_)?([^_]+)(_(.*))?\\.(\\w+)$");

    # 202004291845 or 2020/04/29 18:45 but in order
    #def parseTimeStamp(self, timestamp):
    #    timestamp = re.sub("\W", "", timestamp)
    #    print timestamp
    #    # TODO?

    def set_timestamp(self, timestamp):
        self.TIMESTAMP = re.sub("\W", "", timestamp)

    # NOTE: remove PARAMS!
    # Consider typing (int, str)
    def set_parameter(self, key, value=''):

        if (key == 'FORMAT'):
            # warn?
            self.FORMAT = value
            # todo: EXTENSION, COMPR, TIMESTAMP?
            return
        
        if (self.PARAMETERS == None):
            self.PARAMETERS = {}

        self.PARAMETERS[key] = value

    def set_parameters(self, params):
        for k,v in params.items():
            self.set_parameter(k, v)
            
    def parse(self, filename):

        m = self.compressionRe.match(filename)
        if (m):
            # print 'Compression: {0}'.format(m.group(2))
            self.COMPRESSION = m.group(2)
            filename = m.group(1)
        
        m = self.productRe.match(filename)
        if (m):

            #print (m.groups()) # !DEBUG
            
            # Time variables
            if (m.group(2)):
                self.set_timestamp(m.group(2))
                #self.TIMESTAMP =  re.sub("\W", "", m.group(2))
            else:
                self.set_timestamp('')
        
            # Product id
            self.ID = m.group(3)

            # Product specific parameters
            #if (len(m.groups()) > 5):
            if (m.group(5)):
                # self.PARAMS = m.group(5).split('_')
                # params = m.group(5).split('_')
                # pindex = 0
                for e in m.group(5).split('_'): #self.PARAMS:
                    entry = e.split('=')
                    # consider  self.set_parameter(*entry)
                    self.set_parameter(*entry)
                    #if (len(entry) == 2):
                    #    self.set_parameter(entry[0], entry[1]) 
                    #else:
                    #    self.set_parameter('P'+str(pindex), entry[0])
            #else:
            #    self.PARAMS = {}

            # Format, excluding optional COMPRESSION (parsed above)
            self.FORMAT = m.group(6)
            self.EXTENSION = self.FORMAT
            if (self.COMPRESSION):
                self.EXTENSION = self.EXTENSION + '.' + self.COMPRESSION

        else:
            print ("{0}: ERROR in parsing {1}").format(__name__, filename)

        return self
        
    
    def filename(self):
        body = []
        if (self.TIMESTAMP):
            body.append(self.TIMESTAMP)
        body.append(self.ID)
        
        #if (self.PARAMS):
        #    body.append("_".join(self.PARAMS))

        if (self.PARAMETERS):
            for key,value in sorted(self.PARAMETERS.items()):
                if (value == ''):
                    body.append(key)
                else:
                    body.append("{0}={1}".format(key, value))

            
        return("_".join(body) + '.' + self.FORMAT)

    
    
    # Append or create dict with TIMESTAMP and params
    # Uses PRODUCT instead of ID which is too general (example: "radar.rack.comp")
    def get_param_env(self, env=None):
        if (env == None):
            env = {}
        # Start with these (and override with 'system' variables below).
        env.update(self.PARAMETERS)
        if (self.TIMESTAMP):
            parse_timestamp(self.TIMESTAMP, env)
        env['PRODUCT'] = self.ID    
        #for i in ['ID','FORMAT', 'COMPRESSION', 'EXTENSION']:
        for i in ['FORMAT', 'COMPRESSION', 'EXTENSION']:
            env[i] = getattr(self, i, "")
        
        return env

    def __init__(self, filename = ''):
        self.PARAMETERS = {}
        if (filename):
            self.parse(filename)

    def __call__(self):
        print('Print Something')

        


class ProductServer:
    """Service designed for generating image and data products served as files 
    """

    PRODUCT_ROOT = '.'
    CACHE_ROOT = '.'
    TIME_DIR_SYNTAX = '{YEAR}/{MONTH}/{DAY}'
    SHELL_GENERATOR_SCRIPT = 'generate.sh'
    SHELL_INPUT_SCRIPT = 'input.sh'

    # HTTP Server Options (forward defs HTTP server, so perhaps later moved to NutServer )
    HTTP_PORT = 8088
    HTTP_NAME = ''
    HTTP_PATH_PREFIX = 'nutshell/' # todo
    HTML_ROOT = '.' # todo
    HTML_TEMPLATE = 'template.html' 

    stdout = subprocess.PIPE
    stderr = subprocess.PIPE

    verbosity = 5
    
    class ProductRequest:
        """Container for storing information on requested product and server side resources derived thereof.
        """

        """Server assigned for manufacturing this product"""
        product_server = None

        """Specification of a product instance."""
        product_info = None

        """System-side directory containing script () for generating the product"""
        generator_dir = ''

        """Optional: System-side full path to the generated file, the product."""
        path = ''
        
        """Optional: Actual object (for example, python Image in the future) """
        product = None
        
        # Later, use (dir + file) object
        inputs = {}
        
        # Nutshell native log output
        log = None
        
        # Std output of the generation
        stdout = None
        
        # Error output of the generation
        stderr = None
        
        # Return code of the generation
        returncode = 0

        
        def __init__(self, product_server, product_info):

            self.product_server = product_server
            self.product_info = product_info

            self.generator_dir = product_server.get_generator_dir(product_info)
            self.generator_script = self.generator_dir + os.sep + product_server.SHELL_GENERATOR_SCRIPT
            #self.path = ''
            self.product = None
            self.inputs = {}
            self.log = Log()
            #print "Succeeded: ", self.generator_dir
            # Ensure dir (what about file?)
            #if product_info:
            self.cache_dir = product_server.get_cache_dir(product_info)
            self.out_file  = product_info.filename() # todo: server provides syntax?
            # Target path. Will be cleared (to None) if product generation fails.
            self.path = self.cache_dir+os.sep+self.out_file
   
    class InputInfo:
        
        # 
        inputs = None
        
        # Std output of the generation
        stdout = None
        
        # Error output of the generation
        stderr = None
        
        def __init__(self):
            self.inputs = {}
            
    
    def __init__(self, conffile = ''):
        if (conffile):
            self.read_conf(conffile)
        if __name__ == '__main__':
            self.stdout = os.sys.stdout
            self.stderr = os.sys.stderr


    def read_conf(self, conffile = 'nutshell.cnf'):
        result = nutils.read_conf(conffile)
        # print result
        nutils.set_entries(self, result)

    def get_status(self):  
        return nutils.get_entries(self)
    
    def get_product_dir(self, product_info):
        """Returns directory containing product generator script (generate.sh) and possible configurations etc"""
        return product_info.ID.replace('.', os.sep)

    
    def get_time_dir(self, timestamp):
        if (timestamp):
            timevars = parse_timestamp(timestamp)
            # print timevars
            return self.TIME_DIR_SYNTAX.format(**timevars)+os.sep
        else:
            return ''

    
    def get_generator_dir(self, product_info):
        return self.PRODUCT_ROOT+os.sep+product_info.ID.replace('.', os.sep)


    # needed?
    def get_cache_dir(self, product_info):
        timedir = self.get_time_dir(product_info.TIMESTAMP)
        return self.CACHE_ROOT + os.sep + timedir + self.get_product_dir(product_info)

    # Archive or storage (read-only)
    def get_auxiliary_dir(self, product_info, format):
        timedir = self.get_time_dir(product_info.TIMESTAMP)
        product_dir = product_info.ID.replace('.', os.sep)
        return "self.CACHE_ROOT + os.sep + timedir + self.get_product_dir(product_info)"


    # Generalize?
    def ensure_cache_dir(self, cache_dir):
        """Creates, if non-existent
        """
        # timedir = self.getTimeDir(product_info.TIMESTAMP)
        # cachedir = self.CACHE_ROOT+os.sep+ timedir + self.getProductDir(product_info)
        #if (not os.path.exists(cache_dir)):
        # print 'creating %s' % cacheDir
        try:
            original_umask = os.umask(0)
            os.makedirs(cache_dir, 0o775, True)
            #os.makedirs('full/path/to/new/directory', desired_permission)
        finally:
            os.umask(original_umask)
        #else:
        #    print 'dir exists %s' % cacheDir
        return cache_dir


    def get_input_list(self, product_info):
        """ Used for reading dynamic input configuration generated by input.sh.
        """

        input_info = self.InputInfo()
        #input_info.inputs = {}
        input_info.gdir = self.get_generator_dir(product_info)
        input_info.script = input_info.gdir + os.sep + self.SHELL_INPUT_SCRIPT

        if (os.path.exists(input_info.script)):
            # TODO generalize (how)
            env = product_info.get_param_env()
            #print env # !DEBUG

            p = subprocess.Popen(input_info.script,
                                 cwd=input_info.gdir,
                                 stdout=subprocess.PIPE, # always
                                 stderr=self.stderr, # stdout for cmd-line and subprocess.PIPE (separate) for http usage
                                 shell=True,
                                 env=env)
        
            input_info.stdout,input_info.stderr = p.communicate()

            if (input_info.stdout):
                input_info.stdout = input_info.stdout.decode(encoding='UTF-8')
            if (input_info.stderr):
                input_info.stderr = input_info.stderr.decode(encoding='UTF-8')

            
            #print "Verbosity = {0}".format(type(self.verbosity))
            if (self.verbosity > 8):

                print('------------STDERR------------')
                print(input_info.stderr)
                print('------------STDOUT------------')
                print(input_info.stdout)
                print("Return code={0}".format(p.returncode))

            #print(type(input_info.stdout))
            lines = input_info.stdout.split('\n')
        
            if (p.returncode == 0):
                nutils.read_conf_text(lines, input_info.inputs)
                if (self.verbosity > 9):
                    nutils.print_dict(input_info.inputs)
            else:
                print("Errors (code={0}):".format(p.returncode))
                print('------------')
                print( input_info.stderr)
                print('------------')
                print( input_info.stdout)
                print('pushd',input_info.gdir )
                e=''
                for k,v in env.items():
                    e += ' {0}="{1}"'.format(k,v)
                #print (e, '.'+os.sep+self.SHELL_INPUT_SCRIPT)
                print (e)
                raise SyntaxWarning(lines.pop())  #last
            
        #return input_info.inputs
        return input_info
        


        
    def run_generator(self, product_request, params=None):
        """ Run shell script to generate a product 
        Actually, only generator_dir is read as parameter. Then, stdout and stderr are used for output.
        """

        if (not params):
            params = {}
            
        p = subprocess.Popen('./'+self.SHELL_GENERATOR_SCRIPT,
                             cwd=product_request.generator_dir,
                             stdout=self.stdout,
                             stderr=subprocess.STDOUT, # Use same stream as stdout, be it os.stdout or subprocess.STDOUT
                             shell=True,
                             env=params)
        if (not p):
            print ("Could not execute path=" + path)
            return -1
        
        (product_request.stdout, product_request.stderr) = p.communicate()

        product_request.returncode = p.returncode
        if (p.returncode == 0):
            product_request.product = product_request.path
        
        return p.returncode



    def make_request(self, product_info, actions = ['MAKE']):
        """" Return path or log
        'MAKE' - return the product, if in cache, else generate it and return
        'GENERATE' - generate and store the product, also regenerate even if already exists
        'INPUTS' - generate and store the product, also regenerate even if already exists
        """

        # 'TEST' - generate and store the product, also regenerate even if already exists

        if (self.verbosity > 10):
            print ('Actions:' + ','.join(actions))
                
        product_request = self.ProductRequest(self, product_info)
        
        if (os.path.exists(product_request.path)):
            product_request.log.append('File exists: {0}'.format(product_request.path))
            if ('DELETE' in actions):
                product_request.log.append('Deleting...')
                os.remove(product_request.path)
            elif ('MAKE' in actions): # PATH_ONLY
                product_request.product = product_request.path
                return product_request
        else:
            product_request.log.append('File not found: {0}'.format(product_request.path))

        # only check at this point
        if (os.path.exists(product_request.generator_script)):
            product_request.log.append('Generator script ok: ' + (product_request.generator_script))
        else:
            product_request.log.append('Generator script not found: ' + (product_request.generator_script), 'ERROR: ')
            product_request.path = ''
            return product_request
        
        # TODO: if not stream?
        product_request.log.append('Ensuring cache dir for: ' + product_request.path)
        self.ensure_cache_dir(product_request.cache_dir)

        # TODO: what about true ENV?
        params = product_info.get_param_env() # {})
        params['OUTDIR']  = product_request.cache_dir
        params['OUTFILE'] = product_request.out_file

        # nutils.print_dict(product_request.inputs)
        #print "ENVI1"
        #nutils.print_dict(params)
            
        # Runs input.sh
        product_request.inputs = self.get_input_list(product_info).inputs

        if ('MAKE' in actions):
            # print 'Retrieve inputs'
            inputs = {}
            for i in product_request.inputs:
                product_request.log.append(i, 'INPUTFILE: ')
                input = product_request.inputs[i] # <filename>.h5
                input_info = ProductInfo(input)
                print ('Make input: {0} ({1})'.format(i, input_info.ID))
                inputs[i] = self.make_request(input_info, ['MAKE'] ).path
                product_request.log.append(inputs[i], 'INPUTPATH: ')
            product_request.inputs = inputs
            #product_request.log.extend2(product_request.inputs , 'INPUTPATH: ')


        params['INPUTKEYS'] = ','.join(product_request.inputs.keys())
        params.update(product_request.inputs)

        #print "ENVI2"
        #nutils.print_dict(params)
        #product_request.log.append("----")
     
        # MAIN
        if ('MAKE' in actions):
            product_request.log.append(product_request.path, 'Generating: ')
            product_request.returncode = self.run_generator(product_request, params)
            # print "MAKE: result_code={0} ".format(result_code)

        # print 'Returning...'
            
        return product_request
    




        
if __name__ == '__main__':

    print()
    
    parser = argparse.ArgumentParser()

#    parser.add_argument("-l", "--linkfile", dest="LINKFILE",
#        default="link.h5",
#        help="read input from file", metavar="<file>")

    parser.add_argument("-c", "--conf", dest="CONF",
        default="nutshell.cnf", #ProductServer.CONF_FILE?
        help="read config file", metavar="<file>")

    parser.add_argument("-p", "--product", metavar="<product_file>",
                        dest="PRODUCT",
                        default="",
                        help="product to be handled")

    parser.add_argument("-r", "--request", metavar="<string>",
                        dest="REQUEST",
                        default="",
                        help="comma-separated string of [DELETE|MAKE|INPUTS]")

    parser.add_argument("-d", "--delete",
                        dest="DELETE",
                        action="store_true",
                        #default=False,
                        help="delete product file, same as -r DELETE")

    parser.add_argument("-m", "--make",
                        dest="MAKE",
                        action="store_true",
                        #default=False,
                        help="make product, same as -r MAKE")

    parser.add_argument("-i", "--inputList",
                        dest="INPUTS",
                        action="store_true",
                        help="list input for a product, same as -r INPUTS")

    parser.add_argument("-v", "--verbose", metavar="<level>",
                        dest="VERBOSE",
                        type=int,
                        default=5, 
                        help="Print status messages to stdout")


    
    #(options, args) = parser.parse_args()
    options = parser.parse_args()

    if (not options):
        parser.print_help()
        exit(1)
    
    if (options.VERBOSE > 10):
        print(options)
    #print args

    product_info = ProductInfo()

    if (options.PRODUCT):
        product_info.parse(options.PRODUCT)
        
    product_server = ProductServer()
    product_server.verbosity = options.VERBOSE

    if (options.CONF):
        if (options.VERBOSE > 5):
            print ("reading conf file: {0}".format(options.CONF))
        product_server.read_conf(options.CONF)

    if (options.VERBOSE > 4):
        nutils.print_dict(product_server.get_status())
         

        
    request = []
    
    if (options.INPUTS):
        request.append('INPUTS')

    if (options.REQUEST):
        request.append(options.REQUEST.split(','))
        
    if (options.DELETE):
        request.append('DELETE')

    if (options.MAKE) or not (request):
        request.append('MAKE')

    if (product_info.ID):
        if (options.VERBOSE > 4):
            print('Requests: {0}'.format(str(request)))
        product_request = product_server.make_request(product_info, request)
        if (options.VERBOSE > 5):
            print (product_request.log.str())
        if ('INPUTS' in request):
            nutils.print_dict(product_request.inputs)
        if (product_request.returncode == 0):
            print("SUCCESS")
        else:
            print("FAILED")
    else:
        print('Could not parse product')
        
    exit(0)
