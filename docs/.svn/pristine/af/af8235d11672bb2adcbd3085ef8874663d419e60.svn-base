#!/bin/python
"""Product generator service. """

__version__ = '0.1'
__author__ = 'Markus.Peura@fmi.fi'

#os.environ["http_proxy"]="" #

import os
import re
import argparse
import shutil     # for mv 
import subprocess # for shell escape


from . import nutils
from . import nutproduct



def parse_timestamp2(timestamp, result = {}):
    if (timestamp):
        t = re.sub("\W", "", timestamp)
        result['TIMESTAMP'] = t[0:12] # empty ok?
        result['YEAR']      = t[0:4]
        result['MONTH']     = t[4:6]
        result['DAY']       = t[6:8]
        result['HOUR']      = t[8:10]
        result['MINUTE']    = t[10:12]
    return result


class Log:

    prefix = 'LOG: '
    
    log = []

    def append(self, line):
        self.log.append(self.prefix + line)

    def extend(self, lines):
        # lines = lines.split('\n')
        for i in lines:
            self.append(i)

    def extend2(self, array, prefix = ''):
        for i in array:
            self.append(i+' = '+ array[i], prefix)

    def str(self):
        return '\n'.join(self.log)

    def __call__(self, line, *args): #, **kwargs):
        self.append(str(line))
        for i in args:
            self.append(str(i))
        #for k,v in kwargs:
        #    self.append('{0}={1}'.format(k,v))





class ProductServer:
    """Service designed for generating image and data products served as files 
    """

    PRODUCT_ROOT = '.'
    CACHE_ROOT = '.'
    TIME_DIR_SYNTAX = '{YEAR}/{MONTH}/{DAY}'
    SHELL_GENERATOR_SCRIPT = 'generate.sh'
    SHELL_INPUT_SCRIPT = 'input.sh'

    # HTTP Server Options (forward defs HTTP server, so perhaps later moved to NutServer )
    HTTP_PORT = 8088
    HTTP_NAME = ''
    HTTP_PATH_PREFIX = 'nutshell/' # todo
    HTML_ROOT = '.' # todo
    HTML_TEMPLATE = 'template.html' 

    stdout = subprocess.PIPE
    stderr = subprocess.PIPE

    verbosity = 5

    counter = 0

    class ProductRequest:
        """Container for storing information on requested product and server side resources derived thereof.
        """

        """Server assigned for manufacturing this product"""
        product_server = None

        """Specification of a product instance."""
        product_info = None

        """System-side directory containing script () for generating the product"""
        generator_dir = ''

        """Optional: System-side full path to the generated file, the product."""
        path = ''
        
        """Optional: Actual object (for example, python Image in the future) """
        product = None
        
        # Later, use (dir + file) object
        inputs = {}
        
        # Nutshell native log output
        log = None
        
        # Std output of the generation
        stdout = None
        
        # Error output of the generation
        stderr = None
        
        # Return code of the generation
        returncode = 0

        id = 0
        
        def __init__(self, product_server, product_info):

            self.product_server = product_server
            self.product_info = product_info

            self.generator_dir = product_server.get_generator_dir(product_info)
            self.generator_script = self.generator_dir + os.sep + product_server.SHELL_GENERATOR_SCRIPT
            #self.path = ''
            self.product = None
            self.inputs = {}
            self.log = Log()
            #print "Succeeded: ", self.generator_dir
            # Ensure dir (what about file?)
            #if product_info:
            self.cache_dir = product_server.get_cache_dir(product_info)
            self.out_file  = product_info.filename() # todo: server provides syntax?
            self.id = (++ProductServer.counter)
            #self.out_file_tmp = self.out_file.replace('.'+product_info.FORMAT, '_tmp{0}.{1}'.format(self.id, product_info.FORMAT))
            # Target path. Will be cleared (to None) if product generation fails.
            self.path     = self.cache_dir+os.sep+self.out_file
            self.path_tmp = self.cache_dir+os.sep+'tmp'+os.sep+self.out_file
            # self.path_tmp = self.cache_dir+os.sep+self.out_file_tmp
   
    class InputInfo:
        
        # 
        inputs = None
        
        # Std output of the generation
        stdout = None
        
        # Error output of the generation
        stderr = None

        #
        log = None
        
        def __init__(self):
            self.inputs = {}
            self.log = Log()
            
    
    def __init__(self, conffile = ''):
        if (conffile):
            self.read_conf(conffile)
        if __name__ == '__main__':
            self.stdout = os.sys.stdout
            self.stderr = os.sys.stderr


    def read_conf(self, conffile = 'nutshell.cnf'):
        result = nutils.read_conf(conffile)
        # print result
        nutils.set_entries(self, result)

    def get_status(self):  
        return nutils.get_entries(self)
    
    def get_product_dir(self, product_info):
        """Returns directory containing product generator script (generate.sh) and possible configurations etc"""
        return product_info.ID.replace('.', os.sep)
    
    def get_time_dir(self, timestamp):
        if (timestamp):
            timevars = nutproduct.parse_timestamp(timestamp)
            # print timevars
            return self.TIME_DIR_SYNTAX.format(**timevars)+os.sep
        else:
            return ''
    
    def get_generator_dir(self, product_info):
        return self.PRODUCT_ROOT+os.sep+product_info.ID.replace('.', os.sep)

    # needed?
    def get_cache_dir(self, product_info):
        timedir = self.get_time_dir(product_info.TIMESTAMP)
        return self.CACHE_ROOT + os.sep + timedir + self.get_product_dir(product_info)

    # Archive or storage (read-only)
    def get_auxiliary_dir(self, product_info, format):
        timedir = self.get_time_dir(product_info.TIMESTAMP)
        product_dir = product_info.ID.replace('.', os.sep)
        return "self.CACHE_ROOT + os.sep + timedir + self.get_product_dir(product_info)"


    # Generalize?
    def ensure_cache_dir(self, cache_dir):
        """Creates, if non-existent
        """
        # timedir = self.getTimeDir(product_info.TIMESTAMP)
        # cachedir = self.CACHE_ROOT+os.sep+ timedir + self.getProductDir(product_info)
        # if (not os.path.exists(cache_dir)):
        #  print 'creating %s' % cacheDir
        try:
            original_umask = os.umask(0)
            os.makedirs(cache_dir+os.sep+'tmp', 0o775, True)
            #os.makedirs('full/path/to/new/directory', desired_permission)
        finally:
            os.umask(original_umask)
        #else:
        #    print 'dir exists %s' % cacheDir
        return cache_dir


    def get_input_list(self, product_info, directives = None):
        """ Used for reading dynamic input configuration generated by input.sh.
        directives determine how the product is generated. 
        """

        input_info = self.InputInfo()
        #input_info.inputs = {}
        input_info.gdir = self.get_generator_dir(product_info)
        input_info.script = input_info.gdir + os.sep + self.SHELL_INPUT_SCRIPT



        if (os.path.exists(input_info.script)):
            # TODO generalize (how)
            env = product_info.get_param_env()
            if (directives):
                env.update(directives) 
            #print env # !DEBUG
            #input_info.log(env)
            nutils.print_dict(directives)
            nutils.print_dict(env)
            
            p = subprocess.Popen(input_info.script,
                                 cwd=input_info.gdir,
                                 stdout=subprocess.PIPE, # always
                                 stderr=self.stderr, # stdout for cmd-line and subprocess.PIPE (separate) for http usage
                                 shell=True,
                                 env=env)
        
            input_info.stdout,input_info.stderr = p.communicate()

            if (input_info.stdout):
                input_info.stdout = input_info.stdout.decode(encoding='UTF-8')
            if (input_info.stderr):
                input_info.stderr = input_info.stderr.decode(encoding='UTF-8')

            
            #print "Verbosity = {0}".format(type(self.verbosity))
            if (self.verbosity > 8):
                print('------------STDERR------------')
                print(input_info.stderr)
                print('------------STDOUT------------')
                print(input_info.stdout)
                print("Return code={0}".format(p.returncode))

            #print(type(input_info.stdout))
            lines = input_info.stdout.split('\n')
        
            if (p.returncode == 0):
                nutils.read_conf_text(lines, input_info.inputs)
                if (self.verbosity > 9):
                    nutils.print_dict(input_info.inputs)
            else:
                print("Errors (code={0}):".format(p.returncode))
                print('------------')
                print( input_info.stderr)
                print('------------')
                print( input_info.stdout)
                print('pushd',input_info.gdir )
                e=''
                for k,v in env.items():
                    e += ' {0}="{1}"'.format(k,v)
                #print (e, '.'+os.sep+self.SHELL_INPUT_SCRIPT)
                print (e)
                raise SyntaxWarning(lines.pop())  #last
            
        #return input_info.inputs
        return input_info
        

    # shutil.move(original,target)
    # os.stat('test.py').st_size
    #def file_is_ready(path):
    #    os.stat(path).st_size
         
    def run_generator(self, product_request, params=None):
        """ Run shell script to generate a product 
        Actually, only generator_dir is read as parameter. Then, stdout and stderr are used for output.
        """

        if (params == None):
            params = {}
            
        p = subprocess.Popen('./'+self.SHELL_GENERATOR_SCRIPT,
                             cwd=product_request.generator_dir,
                             stdout=self.stdout,
                             stderr=subprocess.STDOUT, # Use same stream as stdout, be it os.stdout or subprocess.STDOUT
                             shell=True,
                             env=params)
        if (not p):
            print ("Could not execute path=" + path)
            return -1
        
        (product_request.stdout, product_request.stderr) = p.communicate()

        product_request.returncode = p.returncode
        if (p.returncode == 0):
            product_request.product = product_request.path
        
        return p.returncode



    def make_request(self, product_info, actions = ['MAKE'], directives = None):
        """" Return path or log
        'MAKE' - return the product, if in cache, else generate it and return
        'GENERATE' - generate and store the product, also regenerate even if already exists
        'INPUTS' - generate and store the product, also regenerate even if already exists
        """

        # 'TEST' - generate and store the product, also regenerate even if already exists

        if (self.verbosity > 10):
            print ('Actions:' + ','.join(actions))

        # Consider also separate creation and then make_request(product_request)
        product_request = self.ProductRequest(self, product_info)
        
        if (os.path.exists(product_request.path)):
            product_request.log.append('File exists: {0}'.format(product_request.path))
            if ('DELETE' in actions):
                product_request.log.append('Deleting...')
                os.remove(product_request.path)
            elif ('MAKE' in actions): # PATH_ONLY
                if (os.stat(product_request.path).st_size > 0):
                    product_request.product = product_request.path
                else:
                    product_request.product = '' # BUSY
                    product_request.log.append('BUSY')
                return product_request
        else:
            product_request.log.append('File not found: {0}'.format(product_request.path))

        # only check at this point
        if (os.path.exists(product_request.generator_script)):
            product_request.log.append('Generator script ok: ' + (product_request.generator_script))
        else:
            product_request.log.append('Generator script not found: ' + (product_request.generator_script))
            product_request.path = ''
            return product_request
        

        # TODO: if not stream?
        params = {}
        if ('MAKE' in actions):
            product_request.log.append('Ensuring cache dir for: ' + product_request.path)
            self.ensure_cache_dir(product_request.cache_dir)

            # TODO: what about true ENV?
            params = product_info.get_param_env() # {})
            params['OUTDIR']  = product_request.cache_dir+os.sep+'tmp'
            params['OUTFILE'] = product_request.out_file
            os.mknod(product_request.path) # = touch
            
        # Runs input.sh
        product_request.inputs = self.get_input_list(product_info, directives).inputs

        if ('MAKE' in actions):
            # print 'Retrieve inputs'
            inputs = {}
            for i in product_request.inputs:
                product_request.log('INPUTFILE: ', i)
                input = product_request.inputs[i] # <filename>.h5
                input_prod_info = nutproduct.ProductInfo(input)
                print ('Make input: {0} ({1})'.format(i, input_prod_info.ID))
                r = self.make_request(input_prod_info, ['MAKE'] )
                if (r.path):
                    inputs[i] = r.path
                print ('INPUTPATH: ', r.path)
            product_request.log('INPUTPATH: ', inputs)

            product_request.inputs = inputs
            #product_request.log.extend2(product_request.inputs , 'INPUTPATH: ')

            params['INPUTKEYS'] = ','.join(product_request.inputs.keys())
            params.update(product_request.inputs)

        #print "ENVI2"
        #nutils.print_dict(params)
        #product_request.log.append("----")
     
        # MAIN
        if ('MAKE' in actions):
            product_request.log('Generating: ', product_request.path )
            product_request.returncode = self.run_generator(product_request, params)

            if (os.stat(product_request.path_tmp).st_size > 0):
                shutil.move(product_request.path_tmp, product_request.path)
                #product_request.path = product_request.path_final
            # print "MAKE: result_code={0} ".format(result_code)

        # print 'Returning...'
            
        return product_request
    




        
if __name__ == '__main__':

    #print()
    
    parser = argparse.ArgumentParser()

    #    parser.add_argument("-l", "--linkfile", dest="LINKFILE",
    #        default="link.h5",
    #        help="read input from file", metavar="<file>")

    parser.add_argument("-c", "--conf", dest="CONF",
        default="nutshell.cnf", #ProductServer.CONF_FILE?
        help="read config file", metavar="<file>")

    parser.add_argument("-p", "--product", metavar="<id>|<file>",
                        dest="PRODUCT",
                        default="",
                        help="product to be handled")

    parser.add_argument("-r", "--request", metavar="<string>",
                        dest="REQUEST",
                        default="",
                        help="comma-separated string of [DELETE|MAKE|INPUTS]")

    parser.add_argument("-d", "--delete",
                        dest="DELETE",
                        action="store_true",
                        #default=False,
                        help="delete product file, same as -r DELETE")

    parser.add_argument("-m", "--make",
                        dest="MAKE",
                        action="store_true",
                        #default=False,
                        help="make product, same as -r MAKE")

    parser.add_argument("-i", "--inputList",
                        dest="INPUTS",
                        action="store_true",
                        help="list input for a product, same as -r INPUTS")

    parser.add_argument("-D", "--directives",
                        dest="DIRECTIVES",
                        default='',
                        help="additional instructions for product generation")

    parser.add_argument("-v", "--verbose", metavar="<level>",
                        dest="VERBOSE",
                        type=int,
                        default=5, 
                        help="Print status messages to stdout")


    
    #(options, args) = parser.parse_args()
    options = parser.parse_args()

    if (not options):
        parser.print_help()
        exit(1)
    
    if (options.VERBOSE > 10):
        print(options)
    #print args

    product_info = nutproduct.ProductInfo()

    if (options.PRODUCT):
        product_info.parse_filename(options.PRODUCT)
        
    product_server = ProductServer()
    product_server.verbosity = options.VERBOSE

    if (options.CONF):
        if (options.VERBOSE > 5):
            print ("reading conf file: {0}".format(options.CONF))
        product_server.read_conf(options.CONF)

    if (options.VERBOSE > 4):
        nutils.print_dict(product_server.get_status())
         
    request = []
    
    if (options.INPUTS):
        request.append('INPUTS')

    if (options.REQUEST):
        request.append(options.REQUEST.split(','))
        
    if (options.DELETE):
        request.append('DELETE')

    if (options.MAKE) or not (request):
        request.append('MAKE')

    if (product_info.ID):
        if (options.VERBOSE > 4):
            print('Requests: {0}'.format(str(request)))
        directives = {}
        if (options.DIRECTIVES):
            directives = nutils.read_conf_text(options.DIRECTIVES.split(',')) # whattabout comma in arg?
        product_request = product_server.make_request(product_info, request, directives)
        if (options.VERBOSE > 5):
            print (product_request.log.str())
        if ('INPUTS' in request) or (options.VERBOSE > 6):
            #if (options.VERBOSE > 8):   
            nutils.print_dict(product_request.inputs)
        if (product_request.returncode == 0):
            print("SUCCESS")
        else:
            print("FAILED")
    else:
        print('Could not parse product')
        
    exit(0)
