#!/bin/python3
# -*- coding: utf-8 -*-
"""

Product requests -- nutshell.request
====================================================


"""

__version__ = '0.1'
__author__ = 'Markus.Peura@fmi.fi'

# import os
# import re
# import subprocess # for shell escape
# import argparse

from pathlib import Path
from http import HTTPStatus
#import http.server
#HTTPresponses = http.server.SimpleHTTPRequestHandler.responses

import logging
logging.basicConfig(format='%(levelname)s\t %(name)s: %(message)s')
# todo: redesign, now overwriting general settings?


import secrets # for random hex string secrets.token_hex(12)

#logging.basicConfig(format='%(levelname)s:%(message)s', level=logging.DEBUG)
#logging.basicConfig(format='%(asctime)s %(message)s', datefmt='%m/%d/%Y %I:%M:%S %p')
#logging.basicConfig(format='%(asctime)s %(levelname)s %(name)s : %(message)s', datefmt='%Y%m%d%H:%M:%S')

# TODO: rename to action?


from . import nutils
from . import product
from . import shell


class Tasklet(shell.Task):
    """Intermediate class for shell operations (:any:`InputQuery` and :any:`Generator`)
    """
    
    def __init__(self, product_server, product_info, script_filename, log = None):

        if (type(product_info) == str):
            product_info = product.Info(filename = product_info)

        self.GENERATOR_DIR = product_server.get_generator_dir(product_info)          
            
        super().__init__(Path(self.GENERATOR_DIR, script_filename), 
                         env={}, 
                         log=log)

        self.product_server = product_server
        self.product_info   = product_info

        s = self
        filename        = s.product_info.get_filename()
        filename_latest = s.product_info.get_filename_latest()

        s.CACHE_ROOT   = s.product_server.get_cache_root()
        # Needed? :
        s.STORAGE_ROOT = s.product_server.get_storage_root()
        s.TIME_DIR     = s.product_server.get_time_dir(product_info)
        s.PROD_DIR     = s.product_server.get_product_dir(product_info)
        
        s.path_relative = Path(                s.TIME_DIR, s.PROD_DIR, filename)
        s.path_storage  = Path(s.STORAGE_ROOT, s.TIME_DIR, s.PROD_DIR, filename)
        s.path          = Path(s.CACHE_ROOT,   s.TIME_DIR, s.PROD_DIR, filename)
        s.path_tmp      = Path(s.CACHE_ROOT,   s.TIME_DIR, s.PROD_DIR, 'tmp-' + secrets.token_hex(4),  filename)  
        s.path_static   = Path(s.CACHE_ROOT,               s.PROD_DIR, filename)
        s.path_latest   = Path(s.CACHE_ROOT,               s.PROD_DIR, filename_latest)

        s.OUTDIR     = s.path_tmp.parent  # Note         
        s.OUTFILE    = filename        


    #MEMBER_ENV_RE = re.compile("[A-Z]+[A-Z_]*")

    def get_param_env(self):
        return nutils.get_entries(self, product.Info._MEMBER_ENV_RE, str)        
        
    def run2(self, directives = None):
            super().run(str(self.path)+'-'+self.script.name, # short
                        self.product_server.logger.level,
                        directives)

class Generator(Tasklet):
    """Container for storing information on requested product and server side resources derived thereof.
    """

    product_server = None
    """Server assigned for manufacturing this product"""

    product_info = None
    """Specification of a product instance."""

    #path = ''
    path = Path('/tmp')
    """System-side full path to a dynamic directory and the generated product file."""
    
    """System-side full path to the generated file, the product."""
    path_static = Path('/tmp') # ''        
    
    """Optional: System-side full path to the generated product file."""
    path_tmp = Path('/tmp') # ''
 
    """Futue extension: resulting object (for example, python Image) """
    product_obj = None
    
    # Later, use (dir + file) object
    inputs = {}
    
    #instructions = []
    #directives = []
    error_info = None

    # Status, defined using HTTP status codes
    status = HTTPStatus.OK

    sid = 0
    
    builtin_directives = ("LOG", "LATEST", "LINK")        

    def reset_status(self):
        self.status = HTTPStatus.NO_CONTENT
        
    def set_status(self, status):
        """Set success or failure status using http.HTTPStatus codes.
           Setting is logged.
        """
        self.log.debug(status)
        self.status = status
        
    def get_input_list(self, directives): # directives!):
        """ Used for reading dynamic input configuration generated by input.sh.
        directives determine how the product is generated. 
        """

        log = self.log.getChild('get_input_list')

        input_query = InputQuery(self.product_server, self.product_info) 
        
        if (not input_query.script.exists()):
            log.debug("No input script: {0}".format(input_query.script))         
            return input_query   
        
        log.debug(input_query.env)
        
        input_query.run2(directives) ## TODO: directives
    
        if (input_query.returncode == 0): 
            #log.debug(type(input_query.stdout))
            if ((input_query.stdout == '') or (type(input_query.stdout) != str)):
                log.warning("empty stdout of input declaration script {0}:".format(input_query.script))
            else:
                print(input_query.stdout)
                print(type(input_query.stdout))
                nutils.read_conf_text(input_query.stdout.split('\n'), input_query.inputs)
                log.info(input_query.inputs)
            self.inputs = input_query.inputs
        else:
            log.warning("executing failed with error code={0}: {1} ".format(input_query.returncode, input_query.script))
            log.warning(input_query.stdout)
            log.warning(input_query.stderr)
            log.warning(input_query.log)
               
        return input_query


    def remove_files(self):
        """Remove the existing (even empty) files, log as info().
        """
        for p in [self.path, self.path_static, self.path_tmp]:
            if p and p.exists():
                self.log.info("Removing file: {0}".format(p))
                p.unlink() 

    
    def __init__(self, product_server, product_info, log=None):
                #instructions=None, directives=None,

        if not log:
            log = logging.getLogger("Generator")
            log.setLevel(product_server.logger.level)
        
        super().__init__(product_server,
                         product_info,
                         product_server.SHELL_GENERATOR_SCRIPT,
                         log=log)
        
 
        #        if (instructions):
        #            self.instructions = instructions
        #        else:
        #            self.instructions = []
        #        self.log.debug('instructions:' + str(instructions))
        #  
        #        if (directives):              
        #            self.directives = directives
        #        else:
        #            self.directives = []
        #        self.log.debug('directives: ' + str(self.directives))

        self.product_obj = None
        self.inputs = {}
       
        self.env.update(product_info.get_param_env())
        self.env.update(self.get_param_env())
             
        self.reset_status() # 204 HTTPStatus.NO_CONTENT
        self.returncode = -1
        


class InputQuery(Tasklet):
    
    inputs = None
    
    def __init__(self, product_server, product_info):

        #if not log:
        #    log = logging.getLogger("Generator")
        #    log.setLevel(product_server.logger.level)

        super().__init__(product_server, 
                         product_info,
                         product_server.SHELL_INPUT_SCRIPT, 
                         log=logging.getLogger("InputQuery"))
                         
        self.inputs = {}
       
        self.env.update(product_info.get_param_env())
        self.env.update(self.get_param_env()) # OUTDIR, OUTFILE    
        
        self.log.debug("Created env : {0}".format(self.env))
        self.returncode = 0
                


if __name__ == '__main__':

    # parser = argparse.ArgumentParser()
    parser = product.Info.get_arg_parser()
    """
    # Consider leaving "rare" or specific params in-class
    parser.add_argument("-s", "--set", metavar="[<id>|<filename>]",
                        dest="SET",
                        default="",
                        help="product to be handled, recognises argument type")
    """
 
    options = parser.parse_args()

    if (not options):
        parser.print_help()
        exit(1)

    logger = logging.getLogger(__name__)
    logger.setLevel(0)
    
    logger.warn("No demo implemented yet for this module")
    #product_info = product.Info()

    
    
